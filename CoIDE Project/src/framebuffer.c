
/**
 * 	PIN2DMD framebuffer.
 *
 *      (c) 2015 by Joerg Amann, Stefan Rinke
 *
 *	This work is licensed under a Creative 
 *	Commons Attribution-NonCommercial-
 *	ShareAlike 4.0 International License.
 *
 *	http://creativecommons.org/licenses/by-nc-sa/4.0/
 *
 */

//#include <stdlib.h>
#include "malloc.h"
#include "string.h"

#include "framebuffer.h"

uint8_t rgbbuf[targetSubframeSize*targetSubframes]; // we need two bytes as we use one byte for clock



// Startup display
uint8_t displaybuf[displaybufSize] = {
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,
				0x00,0x7F,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0xF0,0xFF,0xC1,0xF3,0x03,0x1C,0xFF,0x1F,0xFF,0x3F,0x78,0x00,
				0xF0,0xF9,0xFF,0x01,0xF0,0xFF,0xC3,0xF3,0x07,0x9C,0xFF,0x3F,0xFF,0x7F,0xF8,0x00,
				0xF8,0xF9,0xFF,0x03,0xF0,0xFF,0xC7,0xF3,0x0F,0x9C,0xFF,0x3F,0x0F,0xF8,0xF8,0x01,
				0xFC,0x79,0xC0,0x07,0xF0,0x80,0xCF,0xF3,0x1F,0x1C,0x00,0x3C,0x0F,0xF0,0xF9,0x03,
				0xFE,0x79,0x80,0x0F,0xF0,0x00,0xCF,0x73,0x3F,0x1C,0x00,0x3C,0x0F,0xE0,0xF9,0x07,
				0xFF,0x79,0x00,0x0F,0xF0,0x00,0xCF,0x73,0x7E,0x1C,0xFE,0x3F,0x0F,0xE0,0xF9,0x8F,
				0xFF,0x79,0x00,0x0F,0xF0,0x80,0xCF,0x73,0xFC,0x1C,0xFF,0x1F,0x0F,0xE0,0x79,0xDF,
				0xE7,0x79,0x00,0x0F,0xF0,0xFF,0xC7,0x73,0xF8,0x9D,0xFF,0x0F,0x0F,0xE0,0x79,0xFE,
				0xE3,0x79,0x00,0x0F,0xF0,0xFF,0xC3,0x73,0xF0,0x9F,0x07,0x00,0x0F,0xF0,0x79,0xFC,
				0xE1,0x79,0x80,0x0F,0xF0,0xFF,0xC1,0x73,0xE0,0x9F,0x07,0x00,0x0F,0xF8,0x79,0xF8,
				0xE0,0x79,0xC0,0x0F,0xF0,0x00,0xC0,0x73,0xC0,0x9F,0xFF,0x3F,0xFF,0xFF,0x78,0x70,
				0xE0,0xF9,0xFF,0x07,0xF0,0x00,0xC0,0x73,0x80,0x9F,0xFF,0x3F,0xFF,0x7F,0x78,0x20,
				0xE0,0xF9,0xFF,0x03,0xF0,0x00,0xC0,0x73,0x00,0x9F,0xFF,0x3F,0xFF,0x3F,0x78,0x00,
				0xE0,0xF9,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,

				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,0x00,0x00,0x7F,0x7F,
				0x00,0x00,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0xF0,0xFF,0xC1,0xF3,0x03,0x1C,0xFF,0x1F,0xFF,0x3F,0x78,0x00,
				0xF0,0xF9,0xFF,0x01,0xF0,0xFF,0xC3,0xF3,0x07,0x9C,0xFF,0x3F,0xFF,0x7F,0xF8,0x00,
				0xF8,0xF9,0xFF,0x03,0xF0,0xFF,0xC7,0xF3,0x0F,0x9C,0xFF,0x3F,0x0F,0xF8,0xF8,0x01,
				0xFC,0x79,0xC0,0x07,0xF0,0x80,0xCF,0xF3,0x1F,0x1C,0x00,0x3C,0x0F,0xF0,0xF9,0x03,
				0xFE,0x79,0x80,0x0F,0xF0,0x00,0xCF,0x73,0x3F,0x1C,0x00,0x3C,0x0F,0xE0,0xF9,0x07,
				0xFF,0x79,0x00,0x0F,0xF0,0x00,0xCF,0x73,0x7E,0x1C,0xFE,0x3F,0x0F,0xE0,0xF9,0x8F,
				0xFF,0x79,0x00,0x0F,0xF0,0x80,0xCF,0x73,0xFC,0x1C,0xFF,0x1F,0x0F,0xE0,0x79,0xDF,
				0xE7,0x79,0x00,0x0F,0xF0,0xFF,0xC7,0x73,0xF8,0x9D,0xFF,0x0F,0x0F,0xE0,0x79,0xFE,
				0xE3,0x79,0x00,0x0F,0xF0,0xFF,0xC3,0x73,0xF0,0x9F,0x07,0x00,0x0F,0xF0,0x79,0xFC,
				0xE1,0x79,0x80,0x0F,0xF0,0xFF,0xC1,0x73,0xE0,0x9F,0x07,0x00,0x0F,0xF8,0x79,0xF8,
				0xE0,0x79,0xC0,0x0F,0xF0,0x00,0xC0,0x73,0xC0,0x9F,0xFF,0x3F,0xFF,0xFF,0x78,0x70,
				0xE0,0xF9,0xFF,0x07,0xF0,0x00,0xC0,0x73,0x80,0x9F,0xFF,0x3F,0xFF,0x7F,0x78,0x20,
				0xE0,0xF9,0xFF,0x03,0xF0,0x00,0xC0,0x73,0x00,0x9F,0xFF,0x3F,0xFF,0x3F,0x78,0x00,
				0xE0,0xF9,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,

				0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0xF0,0xFF,0xC1,0xF3,0x03,0x1C,0xFF,0x1F,0xFF,0x3F,0x78,0x00,
				0xF0,0xF9,0xFF,0x01,0xF0,0xFF,0xC3,0xF3,0x07,0x9C,0xFF,0x3F,0xFF,0x7F,0xF8,0x00,
				0xF8,0xF9,0xFF,0x03,0xF0,0xFF,0xC7,0xF3,0x0F,0x9C,0xFF,0x3F,0x0F,0xF8,0xF8,0x01,
				0xFC,0x79,0xC0,0x07,0xF0,0x80,0xCF,0xF3,0x1F,0x1C,0x00,0x3C,0x0F,0xF0,0xF9,0x03,
				0xFE,0x79,0x80,0x0F,0xF0,0x00,0xCF,0x73,0x3F,0x1C,0x00,0x3C,0x0F,0xE0,0xF9,0x07,
				0xFF,0x79,0x00,0x0F,0xF0,0x00,0xCF,0x73,0x7E,0x1C,0xFE,0x3F,0x0F,0xE0,0xF9,0x8F,
				0xFF,0x79,0x00,0x0F,0xF0,0x80,0xCF,0x73,0xFC,0x1C,0xFF,0x1F,0x0F,0xE0,0x79,0xDF,
				0xE7,0x79,0x00,0x0F,0xF0,0xFF,0xC7,0x73,0xF8,0x9D,0xFF,0x0F,0x0F,0xE0,0x79,0xFE,
				0xE3,0x79,0x00,0x0F,0xF0,0xFF,0xC3,0x73,0xF0,0x9F,0x07,0x00,0x0F,0xF0,0x79,0xFC,
				0xE1,0x79,0x80,0x0F,0xF0,0xFF,0xC1,0x73,0xE0,0x9F,0x07,0x00,0x0F,0xF8,0x79,0xF8,
				0xE0,0x79,0xC0,0x0F,0xF0,0x00,0xC0,0x73,0xC0,0x9F,0xFF,0x3F,0xFF,0xFF,0x78,0x70,
				0xE0,0xF9,0xFF,0x07,0xF0,0x00,0xC0,0x73,0x80,0x9F,0xFF,0x3F,0xFF,0x7F,0x78,0x20,
				0xE0,0xF9,0xFF,0x03,0xF0,0x00,0xC0,0x73,0x00,0x9F,0xFF,0x3F,0xFF,0x3F,0x78,0x00,
				0xE0,0xF9,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,

				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x7F,0x7F,
				0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0xF0,0xFF,0xC1,0xF3,0x03,0x1C,0xFF,0x1F,0xFF,0x3F,0x78,0x00,
				0xF0,0xF9,0xFF,0x01,0xF0,0xFF,0xC3,0xF3,0x07,0x9C,0xFF,0x3F,0xFF,0x7F,0xF8,0x00,
				0xF8,0xF9,0xFF,0x03,0xF0,0xFF,0xC7,0xF3,0x0F,0x9C,0xFF,0x3F,0x0F,0xF8,0xF8,0x01,
				0xFC,0x79,0xC0,0x07,0xF0,0x80,0xCF,0xF3,0x1F,0x1C,0x00,0x3C,0x0F,0xF0,0xF9,0x03,
				0xFE,0x79,0x80,0x0F,0xF0,0x00,0xCF,0x73,0x3F,0x1C,0x00,0x3C,0x0F,0xE0,0xF9,0x07,
				0xFF,0x79,0x00,0x0F,0xF0,0x00,0xCF,0x73,0x7E,0x1C,0xFE,0x3F,0x0F,0xE0,0xF9,0x8F,
				0xFF,0x79,0x00,0x0F,0xF0,0x80,0xCF,0x73,0xFC,0x1C,0xFF,0x1F,0x0F,0xE0,0x79,0xDF,
				0xE7,0x79,0x00,0x0F,0xF0,0xFF,0xC7,0x73,0xF8,0x9D,0xFF,0x0F,0x0F,0xE0,0x79,0xFE,
				0xE3,0x79,0x00,0x0F,0xF0,0xFF,0xC3,0x73,0xF0,0x9F,0x07,0x00,0x0F,0xF0,0x79,0xFC,
				0xE1,0x79,0x80,0x0F,0xF0,0xFF,0xC1,0x73,0xE0,0x9F,0x07,0x00,0x0F,0xF8,0x79,0xF8,
				0xE0,0x79,0xC0,0x0F,0xF0,0x00,0xC0,0x73,0xC0,0x9F,0xFF,0x3F,0xFF,0xFF,0x78,0x70,
				0xE0,0xF9,0xFF,0x07,0xF0,0x00,0xC0,0x73,0x80,0x9F,0xFF,0x3F,0xFF,0x7F,0x78,0x20,
				0xE0,0xF9,0xFF,0x03,0xF0,0x00,0xC0,0x73,0x00,0x9F,0xFF,0x3F,0xFF,0x3F,0x78,0x00,
				0xE0,0xF9,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00};




Palette vgaPalette = { 0,
		{
				0x00,0x00,0x00, 	// black
				0x77,0x00,0x00, 	// dark red
				0xFF,0x00,0x00, 	// red
				0xFF,0x00,0xFF, 	// purple
				0x00,0x77,0x77, 	// teal
				0x00,0x77,0x00, 	// green
				0x00,0xFF,0x00, 	// bright green
				0x00,0xFF,0xFF, 	// turquoise
				0x00,0x00,0x77,		// dark blue
				0x77,0x00,0x77, 	// violet
				0x00,0x00,0xFF, 	// blue
				0x33,0x33,0x33, 	// gray 25%
				0x77,0x77,0x77,		// gray 50%
				0x77,0x77,0x00, 	// dark yellow
				0xFF,0xFF,0x00,  	// yellow
				0xFF,0xFF,0xFF		// white
		},
		NULL };



Palette redPalette = { 1,
		{
				0x00,0x00,0x00,
				0x11,0x00,0x00,
				0x22,0x00,0x00,
				0x33,0x00,0x00,
				0x44,0x00,0x00,
				0x55,0x00,0x00,
				0x66,0x00,0x00,
				0x77,0x00,0x00,
				0x88,0x00,0x00,
				0x99,0x00,0x00,
				0xAA,0x00,0x00,
				0xBB,0x00,0x00,
				0xCC,0x00,0x00,
				0xDD,0x00,0x00,
				0xEE,0x00,0x00,
				0xFF,0x00,0x00
		},
		NULL };

Palette greenPalette = { 2,
		{
				0x00,0x00,0x00,
				0x00,0x11,0x00,
				0x00,0x22,0x00,
				0x00,0x33,0x00,
				0x00,0x44,0x00,
				0x00,0x55,0x00,
				0x00,0x66,0x00,
				0x00,0x77,0x00,
				0x00,0x88,0x00,
				0x00,0x99,0x00,
				0x00,0xAA,0x00,
				0x00,0xBB,0x00,
				0x00,0xCC,0x00,
				0x00,0xDD,0x00,
				0x00,0xEE,0x00,
				0x00,0xFF,0x00
		},
		NULL };

Palette bluePalette = { 3,
		{
				0x00,0x00,0x00,
				0x00,0x00,0x11,
				0x00,0x00,0x22,
				0x00,0x00,0x33,
				0x00,0x00,0x44,
				0x00,0x00,0x55,
				0x00,0x00,0x66,
				0x00,0x00,0x77,
				0x00,0x00,0x88,
				0x00,0x00,0x99,
				0x00,0x00,0xAA,
				0x00,0x00,0xBB,
				0x00,0x00,0xCC,
				0x00,0x00,0xDD,
				0x00,0x00,0xEE,
				0x00,0x00,0xFF
		},
		NULL };

Palette purplePalette = { 4,
		{
				0x00,0x00,0x00,
				0x11,0x00,0x11,
				0x22,0x00,0x22,
				0x33,0x00,0x33,
				0x44,0x00,0x44,
				0x55,0x00,0x55,
				0x66,0x00,0x66,
				0x77,0x00,0x77,
				0x88,0x00,0x88,
				0x99,0x00,0x99,
				0xAA,0x00,0xAA,
				0xBB,0x00,0xBB,
				0xCC,0x00,0xCC,
				0xDD,0x00,0xDD,
				0xEE,0x00,0xEE,
				0xFF,0x00,0xFF

		},
		NULL };

Palette cyanPalette = { 5,
		{
				0x00,0x00,0x00,
				0x00,0x11,0x11,
				0x00,0x22,0x22,
				0x00,0x33,0x33,
				0x00,0x44,0x44,
				0x00,0x55,0x55,
				0x00,0x66,0x66,
				0x00,0x77,0x77,
				0x00,0x88,0x88,
				0x00,0x99,0x99,
				0x00,0xAA,0xAA,
				0x00,0xBB,0xBB,
				0x00,0xCC,0xCC,
				0x00,0xDD,0xDD,
				0x00,0xEE,0xEE,
				0x00,0xFF,0xFF
		},
		NULL };

Palette yellowPalette = { 6,
		{
				0x00,0x00,0x00,
				0x11,0x11,0x00,
				0x22,0x22,0x00,
				0x33,0x33,0x00,
				0x44,0x44,0x00,
				0x55,0x55,0x00,
				0x66,0x66,0x00,
				0x77,0x77,0x00,
				0x88,0x88,0x00,
				0x99,0x99,0x00,
				0xAA,0xAA,0x00,
				0xBB,0xBB,0x00,
				0xCC,0xCC,0x00,
				0xDD,0xDD,0x00,
				0xEE,0xEE,0x00,
				0xFF,0xFF,0x00
		},
		NULL };

Palette greyPalette = { 7,
		{
				0x00,0x00,0x00,
				0x11,0x11,0x11,
				0x22,0x22,0x22,
				0x33,0x33,0x33,
				0x44,0x44,0x44,
				0x55,0x55,0x55,
				0x66,0x66,0x66,
				0x77,0x77,0x77,
				0x88,0x88,0x88,
				0x99,0x99,0x99,
				0xAA,0xAA,0xAA,
				0xBB,0xBB,0xBB,
				0xCC,0xCC,0xCC,
				0xDD,0xDD,0xDD,
				0xEE,0xEE,0xEE,
				0xFF,0xFF,0xFF
		},
		NULL };

#define numberOfPredefinedPalettes 8

Palette* predefinedPalettes[numberOfPredefinedPalettes] = {
		&vgaPalette,
		&redPalette,
		&greenPalette,
		&bluePalette,
		&purplePalette,
		&cyanPalette,
		&yellowPalette,
		&greyPalette,
};

Palette* palettes = NULL;

void initPalettes() {
	int i;
	for( i = 0; i < numberOfPredefinedPalettes; i++ ) {
		addPalette(predefinedPalettes[i]->rgbData, predefinedPalettes[i]->index);
	}
}

Palette* getPalette(uint8_t index) {
	Palette* p = palettes;
	if( p->index == index ) return p;
	while( p->next != NULL ) {
		p = p->next;
		if( p->index == index ) return p;
	}
	return NULL;
}

void deleteAllPalettes() {
	Palette* p = palettes;
	Palette* p1;
	while( p != NULL ) {
		p1 = p->next;
		free(p);
		p = p1;
	}
	palettes = NULL;
}

/**
 * adds a new palette to the palette list. palettes with same index are not
 * overridden. instead only the first one is used
 */
void addPalette(uint8_t* palData, uint8_t index ) {
	Palette* pNew = malloc(sizeof(Palette));
	memcpy( pNew->rgbData, palData, numberOfColorsPerPalette*3 );
	pNew->index = index;
	pNew->next = NULL;
	Palette** p = &palettes;
	while( 1 ) {
		if( *p == NULL ) { // reached end
			*p = pNew;     // add new
			break;
		} else {
			if( (*p)->index == index ) { // found same index -> replace
				Palette* pOld = *p;
				pNew->next = pOld->next;
				*p = pNew;
				free( pOld );
				break;
			}
		}
		p = &( (*p)->next );
	}
}


#define MD5DigestLen 16

void createRGBDisplayBuffer_12bit(uint8_t* src, uint8_t* target, int nSrcSubframes, int nTargetSubframes, int activePalette) {
	uint8_t clock =  1<<6; // bit 6
	int i,j,k,t;
	uint8_t* p = src;

	int palidx[8]; // 8 pixels

	//uint8_t* palBase = getPalette(activePalette)->rgbData;

	uint8_t pixel[nSrcSubframes]; // palindex data for 8 pixels

	for (i = 0; i < subframeSizeInByte; i++) {

		for(j = 0; j < nSrcSubframes; j++) {
			// fetch pixel (palidex) from subframes
			pixel[j] = *( p + j * subframeSizeInByte);
		}
		// init pal index for each pixel
		memset(palidx, 0, sizeof(int) * 8);
		// build pixel palette index by shifting LSB into palidx
		for( k = 0; k < 8; k++ ) {
			for(j= (nSrcSubframes-1); j >= 0 ; j--) {
				palidx[k] = (palidx[k] << 1) + ( pixel[j] & 1 );
				pixel[j] >>= 1;
			}
		}
		// now we have palette index of 8 pixels in palidx[0..7]
		// interate of these 8 pixels
		for (k = 0; k < 8; k++) {

#if 0
			// fetch rgb from palette
			uint8_t* ppal = palBase + (palidx[k] * 3);

			// use as much bits from color value as possible
			uint8_t palshift = nTargetSubframes<8 ? 8 - nTargetSubframes : 0;
			uint8_t red = (*ppal++) >> palshift;
			uint8_t green = (*ppal++) >> palshift;
			uint8_t blue = (*ppal++) >> palshift;
#endif
			uint8_t red = palidx[k] >> 8;
			uint8_t green = ( palidx[k] >> 4 ) & 0x0F;
			uint8_t blue =  palidx[k]  & 0x0F;

			// calculate target index using absolute pixel number
			// but omit HSB, if HSB is set we are in lower pixel
			int targetIdx = ((i * 8 + k) & 0x7FF) * 2;
			int bitShiftOffset = 3;
			uint32_t rgbmask = 0b00111000; // use bit 5,4,3
			if ((i * 8 + k) < targetSubframeSize>>1) {
				bitShiftOffset = 0;
				rgbmask = 0b00000111; // use bit 0,1,2
			}

			for(t=0; t < nTargetSubframes; t++) {
				// do not loop but set all target subframes at once
				target[targetIdx] = (target[targetIdx] & ~rgbmask) |
					((blue & 1) << (bitShiftOffset + 2)) |
					((green & 1) << (bitShiftOffset + 1)) |
					((red & 1) << bitShiftOffset);
				target[targetIdx] = target[targetIdx] & ~clock;
				target[targetIdx+1] = target[targetIdx] | clock;

				red >>= 1; green >>= 1;	blue >>= 1;
				targetIdx += targetSubframeSize;
			} // target subframes

		}

		p++;
	}
}

/**
 * creates a display buffer for direct output via gpio or dma. in case of dma the buffer must be
 * twice times big, because every data byte is written twice first with clock bit 6 set and 2nd
 * with clock bit reset. so without clock target buffer must be 8192 bytes for 128x32 pixel 4 subframes (color planes)
 * including clock bit target buffer must be 16384 byte.
 * @param src source buffer holding 4 subframes one after the other. each buffer 1 bit per pixel, row by row
 * starting top left.
 * @param target target buffer for optimized output. holds 4 subframes one after another one (or two with clock)
 * byte per 2 pixels. upper and lower pixel rows are combined in one byte for a 1/16 scanning panel.
 * bit 2,1,0 holds RGB for upper pixel, bit 5,4,3 holds RGB for lowel pixel. bit 6 is clock if used at all.
 * bit 7 is unsed.
 * @param activePalette an index in the palettes array that holds the actual rgb values for pixels. pixel values
 * from 4 subframes are interpreted as an index from 0 to 15 in such a palette. so each palette can hold 16 different
 * colors.
 * @param insertClock if set to true the target buffer is expanded to 2 byte per two pixels holding the same
 * RGB values for pixels, but contain an addtional clock bit (bit 6), which is set in the first byte and reset in
 * the second.
 */
void createRGBDisplayBuffer_4bit(uint8_t* src, uint8_t* target, int activePalette) {

	uint8_t clock =  1<<6; // bit 6

	// optimized for 4 subframes, use distinct pointer no loop
	int subframe = 0;
	uint8_t* p1 = src + subframe++ * subframeSizeInByte;
	uint8_t* p2 = src + subframe++ * subframeSizeInByte;
	uint8_t* p3 = src + subframe++ * subframeSizeInByte;
	uint8_t* p4 = src + subframe++ * subframeSizeInByte;

	subframe = 0;
	uint8_t* t1 = target + subframe++ * targetSubframeSize;
	uint8_t* t2 = target + subframe++ * targetSubframeSize;
	uint8_t* t3 = target + subframe++ * targetSubframeSize;
	uint8_t* t4 = target + subframe++ * targetSubframeSize;

	int palidx[8];
	int i = 0;
	int b = 0;
	uint8_t* palBase = getPalette(activePalette)->rgbData;

	for (i = 0; i < subframeSizeInByte; i++) {
		// load palindex with palindex for 8 pixel at once
		uint32_t pal = (*p1++ << 24) + (*p2++ << 16) + (*p3++ << 8) + *p4++;

		// init pal index for each pixel
		memset(palidx, 0, sizeof(int) * 8);
		// build pixel palette index by shifting LSB into palidx
		for (b = 0; b < 32; b++) {
			palidx[b & 7] = (palidx[b & 7] << 1) | (pal & 1);
			pal >>= 1;
		}

		// now we have palette index of 8 pixels in palidx[0..7]
		// interate of these 8 pixels
		for (b = 0; b < 8; b++) {
			// fetch rgb from palette
			uint8_t* ppal = palBase + (palidx[b] * 3);

			// just use 4 most significant bits
			uint8_t red = (*ppal++) >> 4;
			uint8_t green = ( *ppal++ ) >> 4;
			uint8_t blue = (*ppal++) >> 4;

			int bitShiftOffset = 0;

			// calculate target index using absolute pixel number
			// but omit HSB, if HSB is set we are in lower pixel
			int targetIdx = ((i * 8 + b) & 0x7FF) * 2;

			uint32_t rgbmask = 0b00111000; // use bit 5,4,3
			if ((i * 8 + b) < targetSubframeSize>>1) {
				bitShiftOffset = 0;
				rgbmask = 0b00000111; // use bit 0,1,2
			} else {
				bitShiftOffset = 3;
			}

			// do not loop but set all target subframes at once
			t1[targetIdx] = (t1[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green&1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t1[targetIdx] = t1[targetIdx] & ~clock;
				t1[targetIdx+1] = t1[targetIdx] | clock;

			red >>= 1; green >>= 1;	blue >>= 1;

			t2[targetIdx] = (t2[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t2[targetIdx] = t2[targetIdx] & ~clock;
				t2[targetIdx+1] = t2[targetIdx] | clock;

			red >>= 1; green >>= 1; blue >>= 1;

			t3[targetIdx] = (t3[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t3[targetIdx] = t3[targetIdx] & ~clock;
				t3[targetIdx+1] = t3[targetIdx] | clock;

			red >>= 1; green >>= 1; blue >>= 1;

			t4[targetIdx] = (t4[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t4[targetIdx] = t4[targetIdx] & ~clock;
				t4[targetIdx+1] = t4[targetIdx] | clock;

		}
	}
}

/**
 * like createRGBDisplayBuffer, but no weighted  subframe bits, just sum
 */
void createRGBDisplayBuffer_2bit(uint8_t* src, uint8_t* target, int activePalette) {

	int wpc_map[] = {0,1,4,15};
	uint8_t clock =  1<<6; // bit 6

	// optimized for 4 subframes, use distinct pointer no loop
	int subframe = 0;
	uint8_t* p1 = src + subframe++ * subframeSizeInByte;
	uint8_t* p2 = src + subframe++ * subframeSizeInByte;
	uint8_t* p3 = src + subframe++ * subframeSizeInByte;
	//uint8_t* p4 = src + subframe++ * subframeSizeInByte;

	subframe = 0;
	uint8_t* t1 = target + subframe++ * targetSubframeSize;
	uint8_t* t2 = target + subframe++ * targetSubframeSize;
	uint8_t* t3 = target + subframe++ * targetSubframeSize;
	uint8_t* t4 = target + subframe++ * targetSubframeSize;

	int palidx[8];
	int i = 0;
	int b = 0;
	uint8_t* palBase = getPalette(activePalette)->rgbData;

	for (i = 0; i < subframeSizeInByte; i++) {
		// load palindex with palindex for 8 pixel at once
		uint32_t pal = (*p1++ << 16) + (*p2++ << 8) + (*p3++ ); //+ *p4++;

		// init pal index for each pixel
		memset(palidx, 0, sizeof(int) * 8);
		// build pixel palette index by shifting LSB into palidx
		for (b = 0; b < 32; b++) {
			palidx[b & 7] = palidx[b & 7]  + (pal & 1);
			pal >>= 1;
		}

		// now we have palette index of 8 pixels in palidx[0..7]
		// interate of these 8 pixels
		for (b = 0; b < 8; b++) {
			// fetch rgb from palette
			uint8_t* ppal = palBase + (wpc_map[palidx[b]] * 3);

			// just use 4 most significant bits
			uint8_t red = (*ppal++) >> 4;
			uint8_t green = ( *ppal++ ) >> 4;
			uint8_t blue = (*ppal++) >> 4;

			int bitShiftOffset = 0;

			// calculate target index using absolute pixel number
			// but omit HSB, if HSB is set we are in lower pixel
			int targetIdx = ((i * 8 + b) & 0x7FF) * 2;

			uint32_t rgbmask = 0b00111000; // use bit 5,4,3
			if ((i * 8 + b) < targetSubframeSize>>1) {
				bitShiftOffset = 0;
				rgbmask = 0b00000111; // use bit 0,1,2
			} else {
				bitShiftOffset = 3;
			}

			// do not loop but set all target subframes at once
			t1[targetIdx] = (t1[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green&1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t1[targetIdx] = t1[targetIdx] & ~clock;
				t1[targetIdx+1] = t1[targetIdx] | clock;

			red >>= 1; green >>= 1;	blue >>= 1;

			t2[targetIdx] = (t2[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t2[targetIdx] = t2[targetIdx] & ~clock;
				t2[targetIdx+1] = t2[targetIdx] | clock;

			red >>= 1; green >>= 1; blue >>= 1;

			t3[targetIdx] = (t3[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t3[targetIdx] = t3[targetIdx] & ~clock;
				t3[targetIdx+1] = t3[targetIdx] | clock;

			red >>= 1; green >>= 1; blue >>= 1;

			t4[targetIdx] = (t4[targetIdx] & ~rgbmask) |
				((blue & 1) << (bitShiftOffset + 2)) |
				((green & 1) << (bitShiftOffset + 1)) |
				((red & 1) << bitShiftOffset);
				t4[targetIdx] = t4[targetIdx] & ~clock;
				t4[targetIdx+1] = t4[targetIdx] | clock;

		}
	}
}





